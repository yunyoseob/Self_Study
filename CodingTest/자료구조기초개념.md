# 자료 구조

자료 구조의 개념
--

자료 구조는 컴퓨터상 자료를 효율적으로 저장하기 위해 만들어진 논리적인 구조이다.

자료 구조의 현명한 선택을 통해 효율적인 알고리즘을 사용할 수 있게 하여 성능을 향상시킨다.

**✔ 자료 구조의 분류**

```
선형 구조
    ㄴ 데이터를 연속적으로 연결한 자료구조 (리스트, 스택, 큐, 데크)

비선형 구조
    ㄴ 데이터를 비연속적으로 연결한 자료구조 (트리, 그래프)
```

## 선형 구조

<hr>

### 리스트

**✔ 리스트의 종류**

1. 선형 리스트

- 배열과 같이 연속되는 기억 장소에 저장되는 리스트
- 선형 리스트의 대표적인 구조로는 배열(Array) 등이 있음
- 가장 간편한 자료 구조이며, 접근 구조가 빠름
- 자료의 삽입, 삭제 시 기존 자료의 이동이 필요

2. 연결 리스트

- 노드의 포인터 부분으로 서로 연결시킨 리스트
- 연결하는 방식에 따라 단순 연결 리스트, 원형 연결 리스트, 이중 연결 리스트, 이중원형 연결 리스트로 구분
- 노드의 삽입, 삭제가 선형 리스트와 달리 편리
- 연결을 위한 포인터가 추가되어 저장 공간이 추가로 필요
- 포인터를 통해 찾는 시간이 추가되어 선형 리스트에 비해 느림

### 스택

스택은 한 방향으로만 자료를 넣고 꺼낼 수 있는 LIFO(Last-In First-Out) 형식의 자료 구조이다.

- 스택 응용 분야

```
인터럽트의 처리 : 현재 진행 중인 명령어의 위치를 스택에 PUSH하고, 인터럽트 발생 상황을 처리한 후에 인터럽트 전에 진행 중이던 명령어 위치를 스택에서 POP을 통해 받아옴

함수 호출(재귀 호출 포함) : 함수를 호출 시 현재 진행 중인 명령어 주소를 스택에 저장

후위표현 연산 : Postfix를 계산할 때 사용

깊이 우선 탐색(DFS: Depth-First Search) : 깊이 내려갈 때마다 스택에 값을 PUSH하고, 더 이상 깊이 갈 곳이 없을 경우 스택에서 POP한 노드와 인접한 노드를 찾음
```

### 큐

큐는 한쪽 끝에서는 삽입 작업이 이뤄지고, 반대쪽 끝에서는 삭제 작업이 이루어지는 FIFO(First-In First-Out) 형식의 자료 구조이다.

- 큐 연산

```
ENQUEUE : 데이터를 차례대로 넣는 연산
DEQUEUE : 처음 저장된 데이터부터 하나씩 꺼내는 연산
```

### 데크 

데크는 큐의 양쪽 끝에서 삽입과 삭제를 할 수 있는 자료 구조이다.

- 데크 연산

```
PUSH : 데이터를 차례대로 데크에 넣는 연산
POP : 데크에서 Front와 Rear에 있는 데이터를 하나씩 꺼내는 연산
```

## 비선형 구조

### 트리

트리는 데이터들을 계층화시킨 자료 구조이다.

그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조이다.

배열과 달리 노드들이 포인터로 연결되어 노드의 상한선이 없다.

- 트리 순회방법

```
전위 순회 : Root => Left => Right 순으로 방문

중위 순회 : Left => Root => Right 순으로 방문

후위 순회 : Left => Right => Root 순으로 방문
```

<img src="https://t1.daumcdn.net/cfile/tistory/99473F485BDEEC3E17" height="300" width="300" align="center">

<br>

- 사진 출처 : [REAKWON님 블로그](https://reakwon.tistory.com/36)

```
다음과 같이 있을 때, 

- 전위 순회

A => B => D => G => H => E => C => F => I => J

- 중위 순회

G => H => D => E => B => I => J => F => C => A

- 후위 순위

G => H => D => E => B => I => J => F => C => A

```

- 트리 종류

```
1. 이진 탐색 트리(Binary Search Tree)

- 이진 탐색 트리는 차수가 2 이하인 노드로 구성되어 자식이 둘 이하로 구성된 트리이다.

- 이진 탐색 트리는 부모 노드보다 작은 값은 왼쪽으로 부모 노드보다 큰 값은 오른쪽 노드에 생성된다.

2. AVL 트리(Adelson-Veisky and Landis Tree)

- AVL 트리는 두 자식 서브 트리의 높이는 항상 최대 1만큼만 차이가 나도록 스스로 균형을 잡는 이진 탐색 트리이다.

3. 2-3트리(2-3 Tree)

- 2-3 트리는 차수가 2 또는 3인 내부 노드를 갖는 탐색 트리이다.
- AVL 트리의 단점인 삽입과 삭제 시의 전체 트리를 재구성하는 부분을 줄인 트리이다.

4. 레드-블랙 트리

레드-블랙 트리(Red-Black Tree)의 각 노드는 빨강 또는 검정의 색상을 가지고 있으며, 색깔에 따른 규칙을 통해 스스로 균형을 잡는 이진 탐색 트리이다.
```

### 그래프

그래프는 노드(N : Node)와 노드를 연결하는 간선(E : Edge)을 하나로 모아놓은 자료 구조이다.

※ 트리는 사이클이 없는 그래프이다.

- 그래프 유형

```
방향성의 유무에 따라 방향 그래프와 무방향 그래프로 구분된다.

1. 방향 그래프

- 정점을 연결하는 선에 방향이 있는 그래프

- n개의 정점으로 구성된 방향 그래프의 최대 간선 수는 n(n-1)

2. 무방향 그래프

- 정점을 연결하는 선에 방향이 없는 그래프

- n개의 정점으로 구성된 무방향 그래프의 최대 간선 수는 n(n-1)/2
```

- 그래프 탐색 방법

```
1. 깊이 우선 탐색(DFS : Depth-First Search) 

최대한 깊게 내려간 뒤, 더 이상 깊이 갈 곳이 없을 경우 옆으로 이동

2. 너비 우선 탐색(BFS : Breadth-First Search)

최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동
```

<img src="https://mblogthumb-phinf.pstatic.net/MjAxNzAxMTdfMTM2/MDAxNDg0NjYwNjA2NTI3.PiD2qNZvFF8XNyX5_x1hokA45NZ1u19wSbdRoC8E6eYg.2IeaaSuK0UsoGhpUQeR3myNQhB8nIHJ9Ntf5dFOqvJog.PNG.591923/%EC%BA%A1%EC%B2%98.PNG?type=w2" height="300" width="300" align="center">

<br>

- 사진 출처 : [591923님 블로그](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=591923&logNo=220913738926)