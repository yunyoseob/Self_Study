# 알고리즘

알고리즘의 개념
--

알고리즘은 어떠한 문제를 해결하기 위한 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 기법이다.

## 알고리즘의 특성

알고리즘의 표현은 자연어, 순서도, 의사 코드, 프로그래밍 언어를 이용하는 방법이 있으며, 따라서 프로그래밍 언어가 아니더라도 알고리즘의 표현은 가능하다.

- 알고리즘 특성

|유형|설명|
|:--:|:--|
|입력|외부로부터 입력되는 자료가 0개 이상|
|출력|출력되는 결과가 1개 이상|
|명확성|각 명령어의 의미가 명확|
|유한성|정해진 단계를 지나면 종료|
|유효성|모든 명령은 실행이 가능한 연산들이어야 함|

## 알고리즘 기법

|기법|설명|
|:--:|:--|
|분할과 정복<br>(Divide and Conquer)|문제를 나눌 수 없을 때까지 나누고, 각각을 풀면서 다시 병합하여 문제의 답을 얻는 알고리즘|
|동적계획법<br>(Dynamic Programming)|어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는 방식의 알고리즘|
|탐욕법<br>(Greedy)|결정을 해야할 때마다 그 순간에 가장 좋다고 생각되는 것을 해답으로 선택함으로써 최종적인 해답에 도달하는 방식의 알고리즘|
|백트래킹<br>(Backtracking)|어떤 노드의 유망성 점검 후, 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후 다른 자손노드를 검색하는 알고리즘|

## 시간 복잡도에 따른 알고리즘 분류

|복잡도|설명|대표 알고리즘|
|:--:|:--|:--|
|O(1)|- 상수형 복잡도 <br> - 자료 크기 무관하게 항상 같은 속도로 작동 <br> - 알고리즘 수행 시간이 입력 데이터 수와 관계없이 일정|해시 함수(Hash Function)|
|O($log_2n$)|- 로그형 복잡도 <br> - 문제를 해결하기 위한 단계의 수가 $log_2n$번만큼의 수행 시간을 가짐|이진 탐색(Binary Search)|
|O(n)|- 선형 복잡도 <br> - 입력 자료를 차례로 하나씩 모두 처리 <br> - 수행 시간이 자료 크기와 직접적 관계로 변함 정비례|순차 탐색(Sequential Search)|
|O($nlog_2n$)|- 선형 로그형 복잡도 <br> - 문제를 해결하기 위한 단계의 수가 $nlog_2n$번만큼의 수행 시간을 가짐|퀵 정렬, 합병 정렬(병합 정렬), 힙 정렬|
|O($n^2$)|- 제곱형 주요 처리 루프 구조가 2중인 경우 <br> - n크기 작을 때에는 $n^2$이 $nlog_2n$보다 빠를 수 있음|거품 정렬, 삽입 정렬, 선택 정렬|

## 알고리즘 설명

- 해싱함수 : 해싱함수(해시함수)는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.

※ 해싱함수 종류

|함수|설명|
|:--:|:--|
|제산법<br>(Division)|나머지 연산자(%)를 사용하여 테이블 주소를 계산하는 방식|
|제곱법<br>(Square)|제곱법은 레코드 키값을 제곱한 후에 결괏값의 중간 부분에 있는 몇 비트를 선택하여 해시 테이블의 홈 주소로 사용하는 방식|
|숫자 분석법<br>(Digit Analysis)|레코드 키를 구성하는 수들이 모든 키들 내에서 자리별로 어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿수를 필요한 만큼 선택하여, 레코드의 홈 주소로 사용하는 방법|
|폴딩법<br>(Folding)|레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR 한 값을 홈 주소로 사용하는 방식|
|기수변환법<br>(Radix)|어떤 진법으로 표현된 주어진 레코드 키를 다른 진법으로 간주하고 키를 변환하여 홈 주소를 얻는 형식(어떤 키값이 16진법으로 표현되어 있다면 이를 10진법으로 표현된 것으로 간주하고 키값을 변환하여 홈 주소를 계산)|
|무작위방법<br>(Random)|난수를 발생시켜 각 레코드 키의 홈 주소를 결정하는 방식|

- 검색 알고리즘

```
1. 순차 검색(Sequential Search)

순차 검색은 배열의 처음부터 끝까지 차례대로 비교하여 원하는 데이터를 찾아내는 알고리즘이다.

2. 이진 검색(Binary Search)

- 이진 검색은 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 알고리즘이다.

- 탐색 효율이 좋고 탐색 시간이 적게 소요된다.

- 가운데 레코드 번호를 찾기 위해서는 다음 식을 사용한다. (소수점이 나올 경우 버림 처리한다.)
```

※ 이진 탐색 가운데 레코드 번호

$M=[\frac{F+L}{2}]$

F : 남은 범위 내에서 첫 번째 레코드 번호

L : 남은 범위 내에서 마지막 레코드 번호

M : 남은 범위 내에서 가운데 레코드 번호

- 정렬 알고리즘

```
1. 퀵 정렬

- 퀵 정렬은 피벗을 두고 피벗의 왼쪽에는 피벗보다 작은 값을 오른쪽에는 큰 값을 두는 과정을 반복하는 알고리즘이다.

- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.

2. 합병 정렬

합병 정렬은 전체 원소를 하나 단위로 분할한 후 분할한 원소를 다시 합병해서 정렬하는 알고리즘이다.

3. 힙 정렬

- 힙 정렬은 정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 알고리즘이다.

- 완전이진 트리(Complete Binary Tree)로 입력 자료의 레코드를 구성한다.

4. 거품 정렬

- 거품 정렬은 인접한 2개의 레코드 키값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 알고리즘이다.

- 두 인접한 원소를 교환하는 과정이 거품 모양과 같다고 하여 거품 정렬이라고 이름이 지어졌다.

- 한 PASS를 수행할 때마다 가장 큰 값이 맨 뒤로 이동하기 때문에, PASS를 '요소의 개수-1'번 수행하게 되면 모든 숫자가 정렬된다.


5. 삽입 정렬

- 삽입 정렬은 2번째 키와 첫 번째 키를 비교하여 순서대로 나열하고, 이어서 3번째 키를 1,2번째 키와 비교해 순서대로 나열하고, 계속해서 N번째 키를 앞의 (n-1)개 키와 비교하여 알맞은 순서에 삽입하는 알고리즘이다.

- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.

6. 선택 정렬

선택 정렬은 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 정렬되지 않은 부분의 가장 앞의 데이터와 교환해나가는 알고리즘이다.
```

✔ 퀵 정렬 수행시간

|시간|복잡도|
|:--:|:--:|
|최적 수행 시간|$O(nlog_2n)$|
|평균 수행 시간|$O(nlog_2n)$|
|최악 수행 시간|$O(n^2)$|

✔ 합병 정렬 수행시간

|시간|복잡도|
|:--:|:--:|
|최적 수행 시간|$O(nlog_2n)$|
|평균 수행 시간|$O(nlog_2n)$|
|최악 수행 시간|$O(nlog_2n)$|

✔ 퀵 정렬 수행시간

|시간|복잡도|
|:--:|:--:|
|최적 수행 시간|$O(nlog_2n)$|
|평균 수행 시간|$O(nlog_2n)$|
|최악 수행 시간|$O(nlog_2n)$|